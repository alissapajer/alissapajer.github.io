<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Alissa Pajer's Blorg - LuneTron</title><link>/</link><description></description><lastBuildDate>Thu, 19 Jun 2014 00:00:00 +0000</lastBuildDate><item><title>Notions of Variance in Scala</title><link>/notions-of-variance-in-scala.html</link><description>&lt;p&gt;Here is a &lt;a href="https://gist.github.com/alissapajer/50c912d739346c1f00dd"&gt;github gist&lt;/a&gt; with some exercises explaining variance of functors in Scala. Additionally, it explains variance of types over their type parameters.&lt;/p&gt;
&lt;p&gt;I also wrote up a &lt;a href="/images/FunctorMorphismPreservationProof.pdf"&gt;proof&lt;/a&gt; that a given functor implementation preserves morphism composition.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">LuneTron</dc:creator><pubDate>Thu, 19 Jun 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:None,2014-06-19:/notions-of-variance-in-scala.html</guid><category>misc</category></item><item><title>Haskell Fixity</title><link>/haskell-fixity.html</link><description>&lt;p&gt;Let's consider some Haskell. Here's a function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;zipSum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Num&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;zipSum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;zipWith&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This function will zip the two provided lists and then sum the pairs of elements, returning a single list of &lt;code&gt;Num&lt;/code&gt;. For example: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;*Main&amp;gt; zipSum [1,2,3,4] [3,4]&lt;/span&gt;
&lt;span class="err"&gt;[4,6]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Great, so …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">LuneTron</dc:creator><pubDate>Sat, 15 Mar 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:None,2014-03-15:/haskell-fixity.html</guid><category>misc</category></item><item><title>Haskell Flip</title><link>/haskell-flip.html</link><description>&lt;p&gt;How can we change the order of the arguments to a function? After I answered this question, I realized it's actually a very odd question to ask.&lt;/p&gt;
&lt;p&gt;I'm working my way though &lt;a href="http://learnyouahaskell.com/"&gt;Learn You a Haskell for Great Good&lt;/a&gt;, and in the &lt;a href="http://learnyouahaskell.com/higher-order-functions#curried-functions"&gt;Curried Functions&lt;/a&gt; section, the author describes the Haskell …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">LuneTron</dc:creator><pubDate>Sat, 22 Feb 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:None,2014-02-22:/haskell-flip.html</guid><category>misc</category></item><item><title>Category Theory at Strange Loop 2013</title><link>/category-theory-at-strange-loop-2013.html</link><description>&lt;p&gt;&lt;img alt="diagram" src="/images/diagram.png" title="diagram"&gt;
Back in September 2013 I gave a talk titled "Category Theory: An Abstraction for Anything" at the &lt;a href="https://thestrangeloop.com/"&gt;Strange Loop Conference&lt;/a&gt;. A few days ago, the &lt;a href="http://www.infoq.com/presentations/category-theory"&gt;video&lt;/a&gt; for my talk was released. &lt;/p&gt;
&lt;p&gt;Additionally, I wrote a &lt;a href="http://engineering.richrelevance.com/closing-the-loop-on-category-theory-polymorphism-currying-and-more/"&gt;blog post&lt;/a&gt; about this talk that was published on my employer's blog. &lt;/p&gt;
&lt;p&gt;Here's the talk …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">LuneTron</dc:creator><pubDate>Wed, 19 Feb 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:None,2014-02-19:/category-theory-at-strange-loop-2013.html</guid><category>misc</category></item><item><title>Blog Setup</title><link>/blog-setup.html</link><description>&lt;p&gt;When I started my search for a static site generator, I first came across &lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt;. I'm not particularly excited about learning Ruby, but I am excited about learning Haskell.
&lt;img alt="HaskellRuby" src="/images/HaskellRuby.png" title="HaskellRuby"&gt;
This quickly led me to &lt;a href="http://jaspervdj.be/hakyll/"&gt;Hakyll&lt;/a&gt;. Hakyll is easy to install with &lt;code&gt;cabal&lt;/code&gt;, though the first time I installed it I …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">LuneTron</dc:creator><pubDate>Sat, 08 Feb 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:None,2014-02-08:/blog-setup.html</guid><category>misc</category></item><item><title>Site Properties</title><link>/site-properties.html</link><description>&lt;p&gt;This site contains all the things that don't contain themselves.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">LuneTron</dc:creator><pubDate>Mon, 03 Feb 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:None,2014-02-03:/site-properties.html</guid><category>misc</category></item><item><title>Insights into Church-Rosser</title><link>/insights-into-church-rosser.html</link><description>&lt;p&gt;&lt;em&gt;This post was originally published on the precog.com engineering blog.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Untyped lambda calculus is powerful. In fact, every computable function can be encoded into lambda calculus, and thus so can every bit of Scala code you've ever written. Though, anything more complicated than your basic combinator would be almost …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">LuneTron</dc:creator><pubDate>Tue, 26 Mar 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:None,2013-03-26:/insights-into-church-rosser.html</guid><category>misc</category></item></channel></rss>