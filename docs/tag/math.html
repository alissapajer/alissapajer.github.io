<!DOCTYPE html>
<html lang="en">
<head>
        <link rel="stylesheet" href="/theme/css/rdark.css" />
        <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
        <link rel="stylesheet" type="text/css" href="/theme/css/luney.css" />
        <link href="/" type="application/atom+xml" rel="alternate" title="Alissa Pajer's Blorg ATOM Feed" /><!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <title>Alissa Pajer's Blorg - math tag</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Alissa Pajer's Blorg Full Atom Feed" />

<!-- Using MathJax, with the delimiters $ -->
<!-- Conflict with pygments for the .mo and .mi -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  "HTML-CSS": {
  styles: {
  ".MathJax .mo, .MathJax .mi": {color: "black ! important"}}
  },
  tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']],processEscapes: true}
  });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Alissa Pajer's Blorg</a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
        </ul></nav><!-- /#menu -->
<section id="content">

<ul>
      <a href="/tag/math.html">math</a>
      <a href="/tag/scala.html">scala</a>
      <a href="/tag/programming.html">programming</a>
      <a href="/tag/haskell.html">haskell</a>
      <a href="/tag/computers.html">computers</a>
</ul>

<!--<h2>Articles tagged with math</h2>
-->

<ul id="post-list">
    <li><article class="hentry">
        <header> 
            <h2 class="entry-title">
                <a href="/posts/research-resources.html" rel="bookmark" title="Permalink to Research Resources">
                    Research Resources</a>
            </h2> 
        </header>
        <footer class="post-info">
            <abbr class="published" title="2021-05-02T00:00:00-04:00"> Sun 02 May 2021 </abbr>
            <!--<address class="vcard author"><a class="url fn" href="/author/alissa-pajer.html">Alissa Pajer</a></address>-->
        </footer><!-- /.post-info -->
        <!--<div class="entry-content"> <h2>TDA Background</h2>
<ul>
<li>
<p><a href="https://arxiv.org/abs/2004.04108">Introductory Topological Data Analysis</a></p>
<ul>
<li><strong>date</strong>: Apr 2020</li>
<li><strong>author</strong>: Dayten Sheffar</li>
<li><strong>summary</strong>: high-level introduction to: metric topology, <span class="math">\(p\)</span>-norm, <span class="math">\(\infty\)</span>-norm, abstract simplexes, simplicial complexes, homeomorphic and homotopy equivalence, nerve theorem, mapper algorithm, betti numbers, persistent homology</li>
</ul>
</li>
<li>
<p><a href="https://pub.ist.ac.at/~edels/Papers/2016-B-01-PersDM.pdf">Persistent Homology</a></p>
<ul>
<li><strong>author</strong>: Herbert Edelsbrunner and Dmitriy Morozov</li>
<li><strong>summary</strong>: glossary of all things persistent homology</li>
</ul>
</li>
<li>
<p><a href="https://pub.ist.ac.at/~edels/Papers/2012-P-11-PHTheoryPractice.pdf">Persistent Homology: Theory and Practice</a></p>
<ul>
<li><strong>author</strong>: Herbert Edelsbrunner, Dmitriy Morozov</li>
<li><strong>summary</strong>: persistent homology survey of methods and applications</li>
</ul>
</li>
<li>
<p><a href="https://arxiv.org/abs/1207.6437">Statistical topological data analysis using persistence landscapes</a></p>
<ul>
<li><strong>date</strong>: Jul 2012</li>
<li><strong>author</strong>: Peter Bubenik</li>
<li><strong>summary</strong>: introduces persistence landscapes to the literature</li>
</ul>
</li>
</ul>
<h2>TDA Theory: Stability</h2>
<ul>
<li>
<p><a href="https://arxiv.org/abs/2103.10723">Notes on an Elementary Proof for the Stability of Persistence Diagrams</a></p>
<ul>
<li><strong>date</strong>: Mar 2021</li>
<li><strong>author</strong>: Primoz Skraba, Katharine Turner</li>
<li><strong>summary</strong>: these notes are a self-contained short proof of the stability of persistence diagrams; the background needed for <a href="https://arxiv.org/abs/2006.16824">arxiv:2006.16824</a></li>
</ul>
</li>
<li>
<p><a href="https://arxiv.org/abs/2006.16824">Wasserstein Stability for Persistence Diagrams</a></p>
<ul>
<li><strong>date</strong>: June 2020</li>
<li><strong>author</strong>: Primoz Skraba, Katharine Turner</li>
</ul>
</li>
<li>
<p><a href="https://arxiv.org/abs/1809.09654">An algebraic Wasserstein distance for generalized persistence modules</a></p>
<ul>
<li><strong>date</strong>: Sep 2018</li>
<li><strong>author</strong>: Peter Bubenik</li>
<li><strong>summary</strong>: persistence modules are the algebraic counterpart to persistence diagrams; defines the Wasserstein distance for persistence modules; proves that the distance of a persistence module and its persistence diagram agree</li>
</ul>
</li>
</ul>
<h2>TDA Theory: Computation</h2>
<ul>
<li>
<p><a href="https://geometry.stanford.edu/papers/zc-cph-05/zc-cph-05.pdf">Computing Persistent Homology</a></p>
<ul>
<li><strong>date</strong>: Nov 2004</li>
<li><strong>author</strong>: Afra Zomorodian and Gunnar Carlsson</li>
<li><strong>DOI</strong>: <a href="https://doi.org/10.1007/s00454-004-1146-y">DOI</a></li>
<li><strong>summary</strong>: the persistent homology of a filtered <span class="math">\(d\)</span>-dimensional simplicial complex is the standard homology of a graded module over a polynomial ring; gives an algorithm for computing individual persistent homology groups over an arbitrary PID</li>
</ul>
</li>
<li>
<p><a href="https://arxiv.org/abs/2103.05608">Dory: Overcoming Barriers to Computing Persistent Homology</a></p>
<ul>
<li><strong>date</strong>: Mar 2021</li>
<li><strong>author</strong>: Manu Aggarwal, Vipul Periwal</li>
</ul>
</li>
<li>
<p><a href="https://arxiv.org/abs/2003.07989">GPU-Accelerated Computation of Vietoris-Rips Persistence Barcodes</a></p>
<ul>
<li><strong>date</strong>: Mar 2020</li>
<li><strong>author</strong>: Simon Zhang, Mengbai Xiao, Hao Wang</li>
</ul>
</li>
</ul>
<h2>TDA Applications</h2>
<ul>
<li>
<p><a href="https://arxiv.org/abs/2102.09380">Topological data analysis of C. elegans locomotion and behavior</a></p>
<ul>
<li><strong>date</strong>: Feb 2021</li>
<li><strong>author</strong>: Ashleigh Thomas</li>
<li><strong>summary</strong>: uses a sliding-window embedding to turn time series data into a point cloud that remembers the temporal information; thorough and clear intro to persistence diagrams and persistence landscapes</li>
</ul>
</li>
<li>
<p><a href="https://jmlr.org/papers/v21/20-345.html">Topology of Deep Neural Networks</a></p>
<ul>
<li><strong>date</strong>: Apr 2020</li>
<li><strong>author</strong>: Gregory Naitzat, Andrey Zhitnikov, Lek-Heng Lim</li>
</ul>
</li>
</ul>
<h2>Computer Science: Functional Programming</h2>
<ul>
<li>
<p><a href="https://www2.cs.sfu.ca/CourseCentral/831/burton/Notes/July14/free.pdf">Theorems for free!</a></p>
<ul>
<li><strong>date</strong>: June 1989</li>
<li><strong>author</strong>: Philip Wadler</li>
</ul>
</li>
<li>
<p><a href="https://homepages.inf.ed.ac.uk/wadler/papers/lineartaste/lineartaste-revised.pdf">A taste of linear logic</a></p>
<ul>
<li><strong>date</strong>: 1993</li>
<li><strong>author</strong>: Philip Wadler</li>
<li><strong>DOI</strong>: <a href="https://doi.org/10.1007/3-540-57182-5_12">DOI</a></li>
<li><strong>summary</strong>: an introduction to intuitionistic logic and linear logic; how they correspond to type systems for functional languages via the notion of 'Propositions as Type'</li>
</ul>
</li>
<li>
<p><a href="https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for functional programming</a></p>
<ul>
<li><strong>date</strong>: 1993</li>
<li><strong>author</strong>: Philip Wadler</li>
<li><strong>DOI</strong>: <a href="https://doi.org/10.1007/978-3-662-02880-3_8">DOI</a></li>
</ul>
</li>
</ul>
<h2>Computer Science: Parsing</h2>
<ul>
<li>
<p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/05/mison-vldb17.pdf">Mison: A Fast JSON Parser for Data Analytics</a></p>
<ul>
<li><strong>date</strong>: 2017</li>
<li><strong>summary</strong>: push down projections and filters into the parser</li>
</ul>
</li>
<li>
<p><a href="http://www.vldb.org/pvldb/vol11/p1576-palkar.pdf">Filter Before You Parse: Faster Analytics on Raw Data with Sparser</a></p>
<ul>
<li><strong>date</strong>: Aug 2018</li>
<li><strong>summary</strong>: filter pre-parsing</li>
</ul>
</li>
</ul>
<h2>Logic</h2>
<ul>
<li><a href="https://www.lix.polytechnique.fr/~lutz/papers/medial-kurz.pdf">What could a Boolean category be?</a><ul>
<li><strong>date</strong>: Jul 2006</li>
<li><strong>author</strong>: Lutz Stra√üburger</li>
</ul>
</li>
</ul>
<h2>Misc</h2>
<ul>
<li><a href="https://arxiv.org/abs/1904.09828">Magic: The Gathering is Turing Complete</a><ul>
<li><strong>date</strong>: Mar 2019</li>
<li><strong>author</strong>: Alex Churchill, Stella Biderman, Austin Herrick</li>
</ul>
</li>
</ul>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script> </div>--><!-- /.entry-content   not article.summary--> 
    </article></li>
    <hr width=100%>
    <li><article class="hentry">
        <header> 
            <h2 class="entry-title">
                <a href="/posts/2014-02-19-categorytheorystrangeloop.html" rel="bookmark" title="Permalink to Category Theory at Strange Loop 2013">
                    Category Theory at Strange Loop 2013</a>
            </h2> 
        </header>
        <footer class="post-info">
            <abbr class="published" title="2014-02-19T00:00:00-05:00"> Wed 19 February 2014 </abbr>
            <!--<address class="vcard author"><a class="url fn" href="/author/alissa-pajer.html">Alissa Pajer</a></address>-->
        </footer><!-- /.post-info -->
        <!--<div class="entry-content"> <p><img alt="diagram" src="/images/diagram.png" title="diagram">
Back in September 2013 I gave a talk titled "Category Theory: An Abstraction for Anything" at the <a href="https://thestrangeloop.com/">Strange Loop Conference</a>. A few days ago, the <a href="http://www.infoq.com/presentations/category-theory">video</a> for my talk was released. </p>
<p>Additionally, I wrote a <a href="http://engineering.richrelevance.com/closing-the-loop-on-category-theory-polymorphism-currying-and-more/">blog post</a> about this talk that was published on my employer's blog. </p>
<p>Here's the talk abstract, reproduced from the <a href="https://thestrangeloop.com/sessions/category-theory-an-abstraction-for-anything">Strange Loop website</a>:</p>
<p><em>Category theory provides a mathematically sound foundation on which we can create collections of objects and express morphisms between them. Together, along with a few simple rules, a collection of objects and morphisms forms a category to which we can apply many useful results, such as the uniqueness of an identity morphism. Furthermore, once we have a category in hand, we can formally explore the relationships it has with other categories, deducing powerful and practical abstractions.</em></p>
<p><em>The power of category theory lies in the relative simplicity and accessibility of its definitions. From just a handful of straightforward concepts, we can formalize many concrete ideas such as directed acyclic graphs, currying, polymorphic functions, and Haskell itself. This talk will introduce the basics of category theory, while simultaneously diving into specific programming-related examples of categories, functors, and natural transformations. In addition to exploring profound and beautiful concepts, this talk aims to provide you with the tools necessary to recognize category-theoretical patterns in your own programming projects.</em></p> </div>--><!-- /.entry-content   not article.summary--> 
    </article></li>
    <hr width=100%>
    <li><article class="hentry">
        <header> 
            <h2 class="entry-title">
                <a href="/posts/2014-02-03-siteproperties.html" rel="bookmark" title="Permalink to Site Properties">
                    Site Properties</a>
            </h2> 
        </header>
        <footer class="post-info">
            <abbr class="published" title="2014-02-03T00:00:00-05:00"> Mon 03 February 2014 </abbr>
            <!--<address class="vcard author"><a class="url fn" href="/author/alissa-pajer.html">Alissa Pajer</a></address>-->
        </footer><!-- /.post-info -->
        <!--<div class="entry-content"> <p>This site contains all the things that don't contain themselves.</p> </div>--><!-- /.entry-content   not article.summary--> 
    </article></li>
    <hr width=100%>
    <li><article class="hentry">
        <header> 
            <h2 class="entry-title">
                <a href="/posts/2013-03-26-churchrosser.html" rel="bookmark" title="Permalink to Insights into Church-Rosser">
                    Insights into Church-Rosser</a>
            </h2> 
        </header>
        <footer class="post-info">
            <abbr class="published" title="2013-03-26T00:00:00-04:00"> Tue 26 March 2013 </abbr>
            <!--<address class="vcard author"><a class="url fn" href="/author/alissa-pajer.html">Alissa Pajer</a></address>-->
        </footer><!-- /.post-info -->
        <!--<div class="entry-content"> <p><em>This post was originally published on the precog.com engineering blog.</em></p>
<p>Untyped lambda calculus is powerful. In fact, every computable function can be encoded into lambda calculus, and thus so can every bit of Scala code you've ever written. Though, anything more complicated than your basic combinator would be almost indecipherable in its lambda calculus form. As an example, here's what the addition combinator for the Church numerals <code>c_n = Œªfx.fn(x)</code> looks like in lambda calculus: </p>
<div class="highlight"><pre><span></span><code><span class="err">A+ = Œªxypq.xp(ypq)</span>
</code></pre></div>

<p>At first glance it's by no means obvious that you're looking at a way to add natural numbers.</p>
<p><strong>Introductory Definitions:</strong></p>
<p>Before we jump into some more examples, let's step back a minute so I can provide a quick and basic introduction to untyped lambda calculus. The rules are easily accessible, and given that lambda calculus is Turing complete, their simplicity astounds me. (As a side note, because cellular automata are really cool, Conway's Game of Life is another easily definable Turing complete system.)</p>
<p>Now, as promised, the introduction: We define the set <code>ùö≤</code> inductively as follows. Let <code>V</code> be a set of variables <code>v'</code>, <code>v''</code>, etc.</p>
<div class="highlight"><pre><span></span><code><span class="err">(i) If x ‚àà V, then x ‚àà ùö≤.</span>
<span class="err">(ii) If M,N ‚àà ùö≤, then MN ‚àà ùö≤.</span>
<span class="err">(iii) If x ‚àà V and M ‚àà ùö≤, then Œªx.M ‚àà ùö≤.</span>
</code></pre></div>

<p>In (ii), <code>MN</code> denotes application, and you should think of <code>M</code> as a method applied to <code>N</code>. In (iii), the syntax <code>Œªx.M</code> denotes an abstraction, i.e. a function <code>x -&gt; M</code>, where <code>M</code> is not required to depend on <code>x</code>. The most interesting terms in lambda calculus will include an abstraction followed by an application, like so:</p>
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="err">Œª</span><span class="n">x</span><span class="p">.</span><span class="n">M</span><span class="p">)</span><span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="nl">x</span> <span class="p">:</span><span class="o">=</span> <span class="n">N</span><span class="p">]</span>
</code></pre></div>

<p>where <code>N</code> is substituted for every free instance of <code>x</code> in <code>M</code>. This is known formally as Œ≤-reduction. In psuedo lambda calculus, (psuedo because integers are not terms in <code>V</code>), we can consider the example </p>
<div class="highlight"><pre><span></span><code><span class="err">(Œªx.(2*x + 3))4 = 2*4 + 3 = 11</span>
</code></pre></div>

<p><strong>Some Intuitions:</strong></p>
<p>So what's the benefit of thinking about lambda calculus? For me, lambda calculus provides the structure to represent the core of what a function really is: a rule that gets us from one bit of knowledge to another. And if we want to prove something about functions (functions in a generic sense), lambda calculus is the perfect place to come. So what should we prove? Well, intuitively we'd hope that, no matter the strategy (e.g. call by name, call by value, etc.) we use to evaluate our function, we obtain the same result. But wait! Can this always be true? What if our function is an ill-thought-out recursion that loops until we overflow the stack? Can we really guarantee that every call to a function will return a unique result, no matter what strategy we use to evaluate it? The answer is yes, with an added assumption.</p>
<p>To understand what this assumption should be, consider the famous <code>Œ©</code>-combinator: </p>
<div class="highlight"><pre><span></span><code><span class="err">Œ© = (Œªx.xx)(Œªx.xx)</span>
</code></pre></div>

<p>Furthermore consider the lambda term <code>(Œªx.z)Œ©</code>. If we evaluate this term using a call-by-name strategy, then it's simply equal to the constant <code>z</code>, since <code>Œªx.z</code> is a constant function. But if we use a call-by-value strategy, then we'll never be able to further reduce it, since when we apply <code>Œªx.xx</code> to itself we again obtain <code>Œ©</code>. So what we really want to prove is this: If we Œ≤-reduce a lambda term until we cannot reduce it any further, then that final reduced term is unique. Said more formally: If a lambda term has a normal form, then that normal form is unique.</p>
<p><strong>Introduction to Church-Rosser:</strong></p>
<p><img alt="ChurchRosserRight" src="/images/ChurchRosser1.png" title="ChurchRosser1">
In summary, we cannot just pick an evaluation strategy and expect it to yield the same results as all other evaluation strategies, because, as the <code>Œ©</code>-combinator example showed us, a given evaluation strategy may never terminate. But, there is something we can prove for certain: a lambda term has at most one normal form. In order to prove this, we'll outline the proof of a more general theorem, known as the Church-Rosser Theorem. In picture form, it looks like the image to the right, where solid arrows are assumptions and dotted arrows are to be proven.</p>
<p>In word form it states: If a term <code>M</code> Œ≤-reduces to two terms <code>N1</code> and <code>N2</code>, then there exists some <code>N3</code> such that <code>N1</code> and <code>N2</code> each Œ≤-reduce to it.</p>
<p>Given Church-Rosser, our desired statement follows directly. If we let <code>N1</code> and <code>N2</code> in the diagram above be distinct normal forms of <code>M</code>, then by Church-Rosser there exists some <code>N3</code> such that <code>N1</code> and <code>N2</code> each Œ≤-reduce to it. But a normal form term can only Œ≤-reduce to itself, and thus <code>N1 = L</code> and <code>N2 = L</code>. Thus <code>M</code> has at most one normal form, since <code>N1 = N2</code>. </p>
<p>Interestingly, we can also use Church-Rosser to prove the consistency of lambda calculus, that is, that true does not equal false. We define: </p>
<div class="highlight"><pre><span></span><code><span class="err">T = Œªxy.x</span>
<span class="err">F = Œªxy.y</span>
</code></pre></div>

<p>Note that <code>T</code> and <code>F</code> are written as an iterated abstraction, meaning that the abstraction is one of multiple variables (in this case <code>x</code> and <code>y</code>). Iterated abstraction is right associative; for example</p>
<div class="highlight"><pre><span></span><code><span class="err">Œªxyz.xyz</span>
</code></pre></div>

<p>is shorthand for</p>
<div class="highlight"><pre><span></span><code><span class="err">Œªx.(Œªy.(Œªz.xyz))</span>
</code></pre></div>

<p>Now to understand these definitions, if <code>K</code> is a lambda term that equals either <code>T</code> or <code>F</code>, the lambda term <code>KPQ</code> is a way to represent ‚Äúif <code>K</code> then <code>P</code> else <code>Q</code>‚Äù. If <code>T = F</code>, then we‚Äôd be able to perform a series of reductions connecting <code>T</code> and <code>F</code>. But since <code>T</code> and <code>F</code> are both normal forms, we cannot perform such reductions. Thus <code>T</code> does not equal <code>F</code>.</p>
<p><strong>Strip Lemma Basics:</strong></p>
<p><img alt="ChurchRosserRight" src="/images/ChurchRosser2.png" title="ChurchRosser2">
Now in order to prove Church-Rosser, we'll prove a lemma first, namely the Strip Lemma. This lemma states that, if <code>M</code> Œ≤-reduces to <code>N1</code> in a single step, and <code>M</code> Œ≤-reduces to <code>N2</code> in any finite number of steps, there exists an <code>N3</code> such that <code>N1</code> and <code>N2</code> each Œ≤-reduce to it. In diagram form, we have the diagram to the right, where a single arrow represents a single Œ≤-reduction, and a double arrow represents any finite number of Œ≤-reductions. </p>
<p>Note that once we've proven the Strip Lemma, Church-Rosser follows immediately by induction on the natural numbers. (First prove the statement for <code>n=1</code>. Then prove that if the statement holds for an arbitrary <code>n</code>, it holds for <code>n+1</code>.) To see this visually, imagine filling in the Church-Rosser diagram with these strips. </p>
<p>Proceeding with the proof of the Strip Lemma, the correct question to ask is, how do we obtain a candidate <code>N3</code>? Well, we know that <code>M</code> Œ≤-reduces to <code>N1</code> in a single step, so we'll consider this redex and mark it in <code>M</code>. Now as we perform the multiple reductions on <code>M</code> that ultimately reduce to <code>N2</code>, we track this marked lambda term until we reach <code>N2</code>. We now perform the Œ≤-reduction on this marked term in <code>N2</code>, and that produces our candidate <code>N3</code>.</p>
<p>Let's make this idea of marking more formal with some notation. Specifically, to keep track of a certain redex, we'll underline it like this: <code>(<ins>Œª</ins>x.M)N</code>, and we'll keep that lambda underlined until we Œ≤-reduce it. With this new notation, here‚Äôs an example of the Strip Lemma with actual lambda terms. (We‚Äôll introduce <code>œÜ</code> in a couple of paragraphs; for now just think of it as a Œ≤-reduction.)</p>
<p><img alt="ChurchRosser3" src="/images/ChurchRosser3.png" title="ChurchRosser3"></p>
<p><strong>Details of the Proof:</strong></p>
<p>Given that we now allow underlined lambdas in our set of allowed terms, what does this new set look like formally? Let's call it <code><ins>ùö≤</ins></code>. We'll define it inductively, as we defined <code>ùö≤</code> earlier. The first three parts of the definition will be analogous to before, defining variables, application, and abstraction. In the fourth part we will include underlined lambdas only in the case when we have an abstraction followed by an application. This is because the only lambda-terms we need to trace are ones we know will be Œ≤-reduced.</p>
<pre><code>(i) If x ‚àà V, then x ‚àà <ins>ùö≤</ins>.
(ii) If M,N ‚àà <ins>ùö≤</ins>, then MN ‚àà <ins>ùö≤</ins>.
(iii) If x ‚àà V and M ‚àà <ins>ùö≤</ins>, then Œªx.M ‚àà <ins>ùö≤</ins>. 
(iv) If x ‚àà V and M, N ‚àà <ins>ùö≤</ins>, then (<ins>Œª</ins>x.M)N ‚àà <ins>ùö≤</ins>.
</code></pre>

<p>Consider the following diagram. Note that the front rectangle is the same as the diagram in the statement of the Strip Lemma. The other terms, namely <code>M'</code> and <code>N2'</code>, we construct for purposes of the proof.</p>
<p><img alt="ChruchRosser4" src="/images/ChurchRosser4.png" title="ChurchRosser4"></p>
<p>We construct <code>M'</code> to be equivalent to <code>M</code>, except that in it we underlined the <code>Œª</code> that was reduced to obtain <code>N1</code>. The function <code>œà: <ins>ùö≤</ins> -&gt; ùö≤</code> simply erases all underlines, so that</p>
<pre><code>œà((<ins>Œª</ins>x.M)N) = (Œªx.œà(M))œà(N)</code></pre>

<p>We can now apply beta-reductions to <code>M'</code>, analogous to those applied to <code>M</code>, in order to obtain <code>N2'</code>. And now to formally obtain <code>N3</code>, we apply the function <code>œÜ: <ins>ùö≤</ins> -&gt; ùö≤</code> to <code>N2'</code>. And what is <code>œÜ</code>? <code>œÜ</code> is exactly what you'd expect: a function that Œ≤-reduces all underlined terms and keeps all others the same, meaning that</p>
<pre><code>œÜ((<ins>Œª</ins>x.M)N) = œÜ(M)[x := œÜ(N)]</code></pre>

<p>Now that we have our candidate <code>N3</code>, we only need to prove that we can draw solid lines in place of the dotted ones. I will outline a proof showing that <code>N2</code> Œ≤-reduces to <code>N3</code> and will leave the other part of the proof as an exercise for the reader. We will outline a proof of the following diagram, which is the front triangle in the previous diagram.</p>
<p><img alt="ChurchRosser5" src="/images/ChurchRosser5.png" title="ChurchRosser5"></p>
<p>In order to prove this, we will use the method of structural induction. Recall that initially we constructed <code>ùö≤</code> inductively. Thus in order to prove something general about all elements of <code>ùö≤</code>, we can use an induction technique that mimics the way in which we define <code>ùö≤</code>. This is called induction on the structure of <code>ùö≤</code>. Though note that in our case, <code>A ‚àà <ins>ùö≤</ins></code>, so we'll use induction on the structure of <code><ins>ùö≤</ins></code>.</p>
<p>First, the base case:</p>
<p>(i) Let <code>A = x</code> for some <code>x ‚àà V</code>. Then <code>œà(x) = x</code> and <code>œÜ(x) = x</code>. And thus since <code>x</code> Œ≤-reduces to <code>x</code>, we're done.</p>
<p>For the next three cases, we assume the statement holds for the individual terms in <code><ins>ùö≤</ins></code>, and prove that it holds for their application (or abstraction).</p>
<p>(ii) Let <code>A = PQ</code> for <code>P, Q ‚àà V</code>. Assume that <code>œà(P)</code> Œ≤-reduces to <code>œÜ(P)</code> and that <code>œà(Q)</code> Œ≤-reduces to <code>œÜ(Q)</code>. By the definitions of <code>œà</code> and <code>œÜ</code>, show that <code>œà(PQ)</code> Œ≤-reduces to <code>œÜ(PQ)</code>.
(iii) Let <code>A = Œªx.P</code> for <code>P ‚àà V</code>. Assume that <code>œà(P)</code> Œ≤-reduces to <code>œÜ(P)</code>. Using the definitions, show that <code>œà(Œªx.P)</code> Œ≤-reduces to <code>œÜ(Œªx.P)</code>
(iv) Let <code>A = (<ins>Œª</ins>x.P)Q</code> for <code>P, Q ‚àà V</code>. Assume the statement holds for <code>P</code> and <code>Q</code>. Show that <code>œà(A)</code> Œ≤-reduces to <code>œÜ(A)</code>.</p>
<p>And that's the outline of the proof of the Strip Lemma! </p>
<p><strong>Conclusion:</strong></p>
<p>In summary, we gave the definition for a lambda-term, considered the <code>Œ©</code>-combinator as an example of a lambda-term without a normal form, and outlined a proof of the Church-Rosser Theorem. So what does Church-Rosser tell us? If a term has a normal form, then that normal form is unique. This means that if we evaluate a function using two different strategies, the results will be equal. Of course, this doesn't guarantee that every evaluation strategy will terminate. But one thing we know for certain: if we do obtain a result, then that result is unique. </p> </div>--><!-- /.entry-content   not article.summary--> 
    </article></li>
    <hr width=100%>
</ul><!-- /#posts-list -->
</section><!-- /#content -->
</body>
</html>
